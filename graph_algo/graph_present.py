#=================================================
# список вершин V + список ребер E
# перебор всех соседей уходит О(N)
V = {'1', '2', '3', '4', '5', '6', '7'}
E = {('1','2'),
     ('1','7'),
     ('2', '3'),
     ('2', '4'),
     ('4', '5'),
     ('5', '6'),
     ('6', '7'),
     }


#=================================================
# матрица смежности

V = ['1', '2', '3', '4', '5', '6', '7']
# нумеруем вершины от 0 до 6, создаем словарь
index = {V[i]: i for i in range(len(V))}
print(index)

# все петли находятся на главной диагонали
# если граф неориентированный то он будет симметричен относительно главной диагонали
# кол-во 1 в два раза больше ребер
A = [[0, 1, 0, 0, 0, 0, 1],
     [1, 0, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 1, 0, 0],
     [0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1],
     [1, 0, 0, 0, 0, 1, 0],
     ]
# + этого представления - простота реализации
# так же просто проверить соседей и т.п. по списку О(N)

#=================================================
# списки смежности

G = {'1': {'2', '7'},
     '2': {'3', '4'},
     '3': {'2'},
     '4': {'2', '5'},
     '5': {'4', '6'},
     '6': {'5', '7'},
     '7': {'6', '1'}
     }

# перебор соседей
# for naighbor in G[]:
#    print(naighbor)

# import networkX as nx
#====================================================
# чаще всего в качестве входной информации передают список ребер
# код для введения списка ребер

N, M = map(int, input().split()) # вводим кол-во вершин и ребер
graph = {i: set() for i in range(N)} # создаем пустой массив графа
for i in range(M):
     v1, v2 = map(int , input().split()) #вводим с клавиатуры ребра
     graph[v1].add(v2) # если использовать эти две строки то получим неориентированный граф
     graph[v2].add(v1) # с одной строкой - ориентированный




